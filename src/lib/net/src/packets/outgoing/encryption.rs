use ferrumc_config::statics::{get_public_key, get_global_config};
use ferrumc_macros::{packet, NetEncode};
use ferrumc_net_codec::encode::NetEncodeOpts;
use std::io::Write;
use ferrumc_net_codec::net_types::var_int::VarInt;
use ferrumc_net_codec::net_types::length_prefixed_vec::LengthPrefixedVec;
use tracing::trace;
use ferrumc_net_codec::encode::NetEncode;


#[derive(NetEncode, Debug)]
#[packet(packet_id = 0x01)]
pub struct EncryptionRequestPacket {
    pub server_id: String, // should always be empty post 1.7
    pub public_key: Vec<u8>,
    pub verify_token: Vec<u8>, // A sequence of random bytes generated by the server.
    pub should_authenticate: bool, // Whether the client should attempt to authenticate through mojang servers.
}

impl EncryptionRequestPacket {
    pub fn new() -> Self {
        let pubkey = get_public_key().clone();
        let pubkey_length = pubkey.len();
        let verify_token: [u8; 4] = rand::random();
        let verify_token_length = verify_token.len();
        let server_id = "".to_string();



        let a = Self {
            server_id,
            public_key: pubkey,
            verify_token: verify_token.to_vec(),
            should_authenticate: !get_global_config().offline_mode,
        };
        // get a as Vec<u8>
        let server_id = a.server_id.as_bytes().to_vec();
        let pubkey = a.public_key.to_vec();
        let verify_token = a.verify_token.to_vec();
        let should_authenticate = a.should_authenticate;
        trace!("Encryption Request Packet: {server_id:?}, {pubkey:?}, {verify_token:?}, {should_authenticate:?}");
        a
    }
}